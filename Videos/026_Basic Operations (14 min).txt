
You now know a bunch about machine learning.
In this video, I like to
teach you a programing language,
Octave, in which you'll be
able to very quickly implement
the the learning algorithms we've
seen already, and the learning
algorithms we'll see later in this course.
In the past, I've tried to teach machine learning
using a large variety of different programming languages
including C++ Java,
Python, NumPy, and also
Octave, and what I
found was that students were able
to learn the most
productively learn the most quickly
and prototype your algorithms most
quickly using a relatively
high level language like octave.
In fact, what I often
see in Silicon Valley is
that if even if you need to build.
If you want to build a large
scale deployment of a learning
algorithm, what people will often do
is prototype and the language is Octave.
Which is a great prototyping language.
So you can sort of get your learning algorithms working quickly.
And then only if you need
to a very large scale deployment of it.
Only then spend your time
re-implementing the algorithm
to C++ Java or some of the language like that.
Because all the lessons we've learned is
that a time or develop a time.
That is your time.
The machine learning's time is incredibly valuable.
And if you can
get your learning algorithms to work more quickly in Octave.
Then overall you have a
huge time savings by first
developing the algorithms in
Octave, and then implementing and
maybe C++ Java, only after we have the ideas working.
The most common prototyping language I
see people use for machine
learning are: Octave, MATLAB,
Python, NumPy, and R.
Octave is nice because open sourced.
And MATLAB works well
too, but it is expensive for
to many people.
But if you have access to a copy of MATLAB.
You can also use MATLAB with this class.
If you know Python, NumPy,
or if you know R. I do see some people use it.
But, what I see is
that people usually end up
developing somewhat more slowly, and
you know, these languages.
Because the Python, NumPy syntax
is just slightly clunkier than the Octave syntax.
And so because of that, and
because we are releasing starter
code in Octave.
I strongly recommend that you
not try to do the following exercises in this class in NumPy and R.
But that I do recommend that
you instead do the programming exercises
for this class in octave instead.
What I'm going to do in
this video is go through
a list of commands very,
very quickly, and its goal
is to quickly show you the
range of commands and the range of things you can do in Octave.
The course website will have
a transcript of everything I
do, and so after
watching this video you
can refer to the transcript
posted on the course website
when you want find a command.
Concretely, what I recommend
you do is first watch the tutorial videos.
And after watching to the
end, then install Octave on your computer.
And finally, it goes to
the course website, download the transcripts
of the things you see in the
session, and type in
whatever commands seem interesting
to you into Octave, so that it's
running on your own computer, so
you can see it run for yourself.
And with that let's get started.
Here's my Windows desktop, and I'm going to start up Octave.
And I'm now in Octave.
And that's my Octave prompt.
Let me first show the elementary
operations you can do in Octave.
So you type in 5 + 6.
That gives you the answer of 11.
3 - 2.
5 x 8, 1/2, 2^6

is 64.
So those are the elementary math operations.
You can also do logical operations.
So one equals two.
This evaluates to false.
The percent command here means a comment.
So, one equals two, evaluates to false.
Which is represents by zero.
One not equals to two.
This is true.
So that returns one.
Note that a not equal sign
is this tilde equals symbol.
And not bang equals.
Which is what some other
programming languages use.
Lets see large operations one and zero
use a double ampersand sign to
the logical AND.
And that evaluates false.
One or zero is the OR operation.
And that evaluates to true.
And I can XOR one and
zero, and that evaluates to one.
This thing over on the left, this Octave 324.x
equals 11, this is the default Octave prompt.
It shows the, what, the
version in Octave and so on.
If you don't want that prompt,
there's a somewhat cryptic command PF
quote, greater than, greater
than and so on,
that you can use to change the prompt.
And I guess this quote a string in the middle.
Your quote, greater than, greater than, space.
That's what I prefer my Octave prompt to look like.
So if I hit enter.
Oops, excuse me.
Like so.
PS1 like so.
Now my Octave prompt has changed to the greater than, greater than sign.Which,
you know, looks quite a bit better.
Next let's talk about Octave variables.
I can take the variable
A and assign it to 3.
And hit enter.
And now A is equal to 3.
You want to assign a variable, but you don't want to print out the result.
If you put a semicolon, the semicolon
suppresses the print output.
So to do that, enter, it doesn't print anything.
Whereas A equals 3.
mix it, print it out,
where A equals, 3 semicolon doesn't print anything.
I can do string assignment.
B equals high.
Now if I just
enter B it prints out the
variable B. So B is the string high.
C equals 3 greater than colon 1.
So, now C evaluates the true.
If you want to print
out or display a variable, here's how you go about it.
Let me set A equals Pi.
And if I want to print
A I can just type A like so, and it will print it out.
For more complex printing there is
also the DISP command which stands for Display.
Display A just prints out A like so.
You can also display strings
so: DISP, sprintf, two
decimals, percent 0.2,
F, comma, A. Like so.
And this will print out the string.
Two decimals, colon, 3.14.
This is kind of
an old style C syntax.
For those of you that
have programmed C before, this is
essentially the syntax you use to print screen.
So the Sprintf generates a
string that is less
than the 2 decimals, 3.1 plus string.
This percent 0.2 F means
substitute A into here,
showing the two digits after the decimal points.
And DISP takes the string
DISP generates it by the Sprintf command.
Sprintf.
The Sprintf command.
And DISP actually displays the string.
And to show you another
example, Sprintf six decimals
percent 0.6 F comma A.
And, this should print Pi
with six decimal places.
Finally, I was saying, a like so, looks like this. There
are useful shortcuts that type type formats long.
It causes strings by default.
Be displayed to a lot more decimal places.
And format short is a
command that restores the default
of just printing a small number of digits.
Okay, that's how you work with variables.
Now let's look at vectors and matrices.
Let's say I want to assign MAT A to the matrix.
Let me show you an example: 1, 2,
semicolon, 3, 4, semicolon, 5, 6.
This generates a three by
two matrix A whose first
row is 1, 2. Second row
3, 4. Third row is 5, 6.
What the semicolon does is
essentially say, go to
the next row of the matrix.
There are other ways to type this in.
Type A 1, 2 semicolon
3, 4, semicolon, 5, 6, like so.
And that's another equivalent way of
assigning A to be
the values of this three by two matrix.
Similarly you can assign vectors.
So V equals 1, 2, 3.
This is actually a row vector.
Or this is a 3 by 1 vector.
Where that is a fat Y vector,
excuse me, not, this is
a 1 by 3 matrix, right.
Nothing by 1.
If I want to assign
this to a column vector,
what I would do instead is do v 1;2;3.
And this will give me a 3 by 1.
There's a 1 by 3 vector.
So this will be a column vector.
Here's some more useful notation.
V equals 1: 0.1: 2.
What this does is
it sets V to the bunch
of elements that start from 1.
And increments and steps
of 0.1 until you get up to 2.
So if I do this, V is going to be this, you know, row vector.
This is what one by eleven matrix really.
That's 1, 1.1, 1.2, 1.3 and
so on until we
get up to two.
Now, and I can also
set V equals one colon six,
and that sets V to be these numbers.
1 through 6, okay.
Now here are some other ways to generate matrices.
Ones 2.3 is a command
that generates a matrix that
is a two by three matrix
that is the matrix of all ones.
So if I set that c2
times ones two by
three this generates a
two by three matrix that is all two's.
You can think of this as a
shorter way of writing this and
c2,2,2's and you can
call them 2,2,2, which would also give you the same result.
Let's say W equals one's, one
by three, so this is
going to be a row vector
or a row of
three one's and similarly
you can also say w equals
zeroes, one by
three, and this generates a matrix.
A one by three matrix of all zeros.
Just a couple more ways to generate matrices .
If I do W equals
Rand one by three,
this gives me a one
by three matrix of all random numbers.
If I do Rand
three by three.
This gives me a three by
three matrix of all
random numbers drawn from the
uniform distribution between zero and one.
So every time I do
this, I get a different
set of random numbers drawn
uniformly between zero and one.
For those of you that
know what a Gaussian random variable
is or for those of you that
know what a normal random variable
is, you can also set W
equals Rand N, one by three.
And so these are going
to be three values drawn from
a Gaussian distribution with mean
zero and variance or
standard deviation equal to one.
And you can set more complex
things like W equals minus
six, plus the square root
ten, times, lets say
Rand N, one by ten thousand.
And I'm going to put a semicolon at
the end because I don't really want this printed out.
This is going to be a what?
Well, it's going to
be a vector of, with
a hundred thousand, excuse me, ten thousand elements.
So, well, actually, you know what?
Let's print it out.
So this will generate a matrix like this.
Right?
With 10,000 elements.
So that's what W is.
And if I now
plot a histogram of W
with a hist command, I can
now. And Octave's print hist
command, you know, takes a
couple seconds to bring this up,
but this is a histogram of
my random variable for W.
There was minus 6 plus zero
ten times this Gaussian random variable.
And I can plot a histogram with
more buckets, with more bins, with say, 50 bins.
And this is my
histogram of a Gaussian with mean minus 6.
Because I have a minus
6 there plus square root 10 times this.
So the variance of
this Gaussian random variable
is 10 on the standard deviation is
square root of 10, which is about what?
Three point one.
Finally, one special command
for generator matrix, which is the I command.
So I stands for this
is maybe a pun on the word identity.
It's server set eye 4.
This is the 4 by 4 identity matrix.
So I equals eye 4.
This gives me a 4 by 4 identity matrix.
And I equals eye 5,  eye 6.
That gives me a 6 by
6 identity matrix, i3
is the 3 by 3 identity matrix.
Lastly, to
wrap up this video, there's one more useful command.
Which is the help command.
So you can type help i and
this brings up the help function for the identity matrix.
Hit Q to quit.
And you can also type help rand.
Brings up documentation for the rand or the
random number generation function.
Or even help help, which
shows you, you know help on the help function.
So, those are the
basic operations in Octave.
And with this you should be
able to generate a few matrices, multiply, add things.
And use the basic operations in Octave.
In the next video, I'd like
to start talking about more
sophisticated commands and how
to use data around and start to process data in Octave.
